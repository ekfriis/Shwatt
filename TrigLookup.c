#include "TrigLookup.h"

_Fract 
LookupCosine(_Fract theta)
{
   return rbits(LookupCosineInt( bitsr(theta) ));
}

_Fract 
LookupSine(_Fract theta)
{
   return rbits(LookupSineInt( bitsr(theta) ));
}

int16_t LookupCosineInt(int16_t theta)
{
   return LookupSineInt(theta + LOOKUP_HPI_RADS);
}

 // 13878
int16_t LookupSineInt(int16_t theta)
{
   char isNegative                 = 0;

   if (theta < 0) 
   {
      if ( theta == -32768 ) //if exactly -pi
         return 0;

      theta += LOOKUP_PI_RADS;
      isNegative = 1;
   }
   if (theta > LOOKUP_HPI_RADS)
   {
      theta = LOOKUP_PI_RADS - theta;
   }

   //get the corresponding point in the lookup table (rounded down)
   unsigned char firstLookupIndex = (theta >> LOOKUP_INDEX_BITS) & MAX_TABLE_INDEX;
   //get the next point in the lookup table (rounded up/down, accordingly)
   unsigned char secondLookupIndex;

   if(firstLookupIndex == MAX_TABLE_INDEX) //reflect about pi/2
      secondLookupIndex = MAX_TABLE_INDEX-1;
   else
      secondLookupIndex = firstLookupIndex + 1;

   int valueAtFirstPoint  = findSineLookupValue(firstLookupIndex);
   int valueAtSecondPoint = findSineLookupValue(secondLookupIndex);

   // extrapolate between the two points
   unsigned char lowerBits = (theta & LOOKUP_LSB_MASK);

   //int correctionTerm = 0;// = ((valueAtSecondPoint-valueAtFirstPoint)*lowerBits) >> LOOKUP_INDEX_BITS;
   int correctionTerm  = ((valueAtSecondPoint-valueAtFirstPoint)*lowerBits) >> LOOKUP_INDEX_BITS;

   int output = valueAtFirstPoint + correctionTerm;

   if (isNegative)
      return -1*output;
   else
      return output;
}

/*
// this saves 60 byes
int16_t LookupSineInt(int16_t theta)
{
   char isNegative                 = 0;

   if (theta < 0) 
   {
      theta += LOOKUP_PI_RADS;
      isNegative = 1;
   }
   if (theta > LOOKUP_HPI_RADS)
   {
      theta = LOOKUP_PI_RADS - theta;
   }

   //round correctly
   theta += (1 << (LOOKUP_INDEX_BITS - 1));
   unsigned char lookupIndex = (theta >> LOOKUP_INDEX_BITS) & MAX_TABLE_INDEX;

   int output = findSineLookupValue(lookupIndex);

   if (isNegative)
      return (-1)*output;
   else
      return output;
}
*/


#ifdef FullByteLookupTable
lookup_type sineQuarterWaveLookupTableByteAddressed[] PROGMEM  = {
	0x0000,	0x00ca,	0x0194,	0x025d,	0x0327,	0x03f1,	0x04bb,	0x0584,
	0x064e,	0x0718,	0x07e1,	0x08ab,	0x0974,	0x0a3d,	0x0b06,	0x0bcf,
	0x0c98,	0x0d61,	0x0e2a,	0x0ef2,	0x0fbb,	0x1083,	0x114b,	0x1213,
	0x12db,	0x13a2,	0x146a,	0x1531,	0x15f8,	0x16be,	0x1785,	0x184b,
	0x1911,	0x19d7,	0x1a9d,	0x1b62,	0x1c27,	0x1cec,	0x1db0,	0x1e74,
	0x1f38,	0x1ffc,	0x20bf,	0x2182,	0x2245,	0x2307,	0x23c9,	0x248b,
	0x254c,	0x260d,	0x26cd,	0x278e,	0x284d,	0x290d,	0x29cc,	0x2a8a,
	0x2b48,	0x2c06,	0x2cc3,	0x2d80,	0x2e3d,	0x2ef9,	0x2fb4,	0x306f,
	0x312a,	0x31e4,	0x329e,	0x3357,	0x3410,	0x34c8,	0x357f,	0x3636,
	0x36ed,	0x37a3,	0x3859,	0x390e,	0x39c2,	0x3a76,	0x3b29,	0x3bdc,
	0x3c8e,	0x3d3f,	0x3df0,	0x3ea1,	0x3f50,	0x3fff,	0x40ae,	0x415c,
	0x4209,	0x42b6,	0x4362,	0x440d,	0x44b8,	0x4561,	0x460b,	0x46b3,
	0x475b,	0x4802,	0x48a9,	0x494f,	0x49f4,	0x4a98,	0x4b3c,	0x4bdf,
	0x4c81,	0x4d23,	0x4dc3,	0x4e63,	0x4f02,	0x4fa1,	0x503e,	0x50db,
	0x5177,	0x5213,	0x52ad,	0x5347,	0x53e0,	0x5478,	0x550f,	0x55a5,
	0x563b,	0x56d0,	0x5764,	0x57f7,	0x5889,	0x591a,	0x59ab,	0x5a3a,
	0x5ac9,	0x5b57,	0x5be4,	0x5c70,	0x5cfb,	0x5d85,	0x5e0f,	0x5e97,
	0x5f1f,	0x5fa5,	0x602b,	0x60b0,	0x6133,	0x61b6,	0x6238,	0x62b9,
	0x6339,	0x63b8,	0x6436,	0x64b3,	0x652f,	0x65aa,	0x6625,	0x669e,
	0x6716,	0x678d,	0x6803,	0x6878,	0x68ec,	0x6960,	0x69d2,	0x6a43,
	0x6ab3,	0x6b22,	0x6b90,	0x6bfc,	0x6c68,	0x6cd3,	0x6d3d,	0x6da5,
	0x6e0d,	0x6e74,	0x6ed9,	0x6f3d,	0x6fa1,	0x7003,	0x7064,	0x70c4,
	0x7123,	0x7181,	0x71de,	0x7239,	0x7294,	0x72ed,	0x7346,	0x739d,
	0x73f3,	0x7448,	0x749b,	0x74ee,	0x7540,	0x7590,	0x75df,	0x762d,
	0x767a,	0x76c6,	0x7711,	0x775a,	0x77a3,	0x77ea,	0x7830,	0x7875,
	0x78b8,	0x78fb,	0x793c,	0x797c,	0x79bb,	0x79f9,	0x7a36,	0x7a71,
	0x7aab,	0x7ae4,	0x7b1c,	0x7b53,	0x7b88,	0x7bbc,	0x7bf0,	0x7c21,
	0x7c52,	0x7c81,	0x7cb0,	0x7cdd,	0x7d08,	0x7d33,	0x7d5c,	0x7d84,
	0x7dab,	0x7dd1,	0x7df6,	0x7e19,	0x7e3b,	0x7e5c,	0x7e7b,	0x7e9a,
	0x7eb7,	0x7ed3,	0x7eed,	0x7f07,	0x7f1f,	0x7f36,	0x7f4b,	0x7f60,
	0x7f73,	0x7f85,	0x7f96,	0x7fa6,	0x7fb4,	0x7fc1,	0x7fcd,	0x7fd7,
	0x7fe1,	0x7fe9,	0x7fef,	0x7ff5,	0x7ff9,	0x7ffd,	0x7ffe,	0x7fff
};
#endif

#ifdef HalfByteLookupTable
lookup_type sineQuarterWaveLookupTableByteAddressed[] PROGMEM = {
	0x0000,	0x0195,	0x032a,	0x04c0,	0x0654,	0x07e9,	0x097d,	0x0b11,
	0x0ca5,	0x0e38,	0x0fca,	0x115c,	0x12ed,	0x147e,	0x160e,	0x179c,
	0x192a,	0x1ab7,	0x1c43,	0x1dce,	0x1f57,	0x20df,	0x2266,	0x23ec,
	0x2570,	0x26f3,	0x2875,	0x29f4,	0x2b72,	0x2cef,	0x2e69,	0x2fe2,
	0x3159,	0x32ce,	0x3441,	0x35b2,	0x3721,	0x388d,	0x39f8,	0x3b60,
	0x3cc6,	0x3e29,	0x3f8a,	0x40e9,	0x4245,	0x439e,	0x44f5,	0x4649,
	0x479b,	0x48e9,	0x4a35,	0x4b7d,	0x4cc3,	0x4e06,	0x4f46,	0x5082,
	0x51bc,	0x52f2,	0x5425,	0x5555,	0x5681,	0x57aa,	0x58d0,	0x59f2,
	0x5b11,	0x5c2c,	0x5d43,	0x5e57,	0x5f67,	0x6073,	0x617c,	0x6280,
	0x6381,	0x647e,	0x6577,	0x666c,	0x675d,	0x684a,	0x6933,	0x6a18,
	0x6af9,	0x6bd5,	0x6cad,	0x6d81,	0x6e51,	0x6f1c,	0x6fe3,	0x70a6,
	0x7164,	0x721e,	0x72d3,	0x7384,	0x7430,	0x74d8,	0x757b,	0x761a,
	0x76b4,	0x7749,	0x77da,	0x7866,	0x78ed,	0x796f,	0x79ed,	0x7a66,
	0x7ada,	0x7b49,	0x7bb4,	0x7c1a,	0x7c7a,	0x7cd6,	0x7d2d,	0x7d7f,
	0x7dcd,	0x7e15,	0x7e58,	0x7e97,	0x7ed0,	0x7f05,	0x7f34,	0x7f5f,
	0x7f84,	0x7fa5,	0x7fc0,	0x7fd7,	0x7fe8,	0x7ff5,	0x7ffc,	0x7fff
};
#endif

#ifdef QuarterByteLookupTable
lookup_type sineQuarterWaveLookupTableByteAddressed[] PROGMEM = {
	0x0000,	0x0331,	0x0661,	0x0991,	0x0cbf,	0x0fea,	0x1314,	0x163a,
	0x195d,	0x1c7b,	0x1f95,	0x22ab,	0x25ba,	0x28c4,	0x2bc7,	0x2ec3,
	0x31b8,	0x34a5,	0x3789,	0x3a65,	0x3d37,	0x4000,	0x42be,	0x4572,
	0x481a,	0x4ab8,	0x4d49,	0x4fce,	0x5246,	0x54b1,	0x570f,	0x595f,
	0x5ba1,	0x5dd4,	0x5ff8,	0x620d,	0x6412,	0x6608,	0x67ed,	0x69c1,
	0x6b85,	0x6d38,	0x6ed9,	0x7069,	0x71e6,	0x7352,	0x74ab,	0x75f2,
	0x7726,	0x7847,	0x7955,	0x7a4f,	0x7b36,	0x7c0a,	0x7cc9,	0x7d75,
	0x7e0d,	0x7e91,	0x7f01,	0x7f5c,	0x7fa3,	0x7fd6,	0x7ff5,	0x7fff
};
#endif

#ifdef EighthByteLookupTable
lookup_type sineQuarterWaveLookupTableByteAddressed[] PROGMEM = {
        0x0000, 0x067c, 0x0cf3, 0x1362, 0x19c4, 0x2015, 0x2651, 0x2c74,
        0x327a, 0x385e, 0x3e1e, 0x43b5, 0x491f, 0x4e59, 0x5360, 0x582f,
        0x5cc5, 0x611e, 0x6537, 0x690e, 0x6ca0, 0x6fea, 0x72ea, 0x759f,
        0x7807, 0x7a20, 0x7be9, 0x7d60, 0x7e85, 0x7f57, 0x7fd5, 0x7fff
};
#endif


int16_t findSineLookupValue(unsigned char input)
{
#ifndef TrigLookup_UnitTest
   return pgm_read_word_near(sineQuarterWaveLookupTableByteAddressed+input);
#else
   return sineQuarterWaveLookupTableByteAddressed[input];
#endif
}
